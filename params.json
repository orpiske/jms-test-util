{"name":"JMS Test Utils","tagline":"","body":"JMS Test Util\r\n============\r\n\r\nIntroduction\r\n----\r\n\r\nThis is a JUnit-based JMS test utility.\r\n\r\n\r\nBuilding and Installing\r\n----\r\n\r\nYou can use Maven to build the project. No additional configuration or setup\r\nshould* be required. To compile and package the project, please run:\r\n\r\n```\r\nmvn clean package\r\n```\r\n\r\nThe build system will generate deliverables in zip, tar.bz2, tar.gz format.\r\nProject specific jars will also be generated.\r\n\r\n\r\nTo install, just run:\r\n\r\n```\r\nmvn clean install\r\n```\r\n\r\n\r\nUsage and Annotations\r\n----\r\n\r\nUse the JmsTestRunner to run the tests (can be done with the @RunWith JUnit\r\nannotation), annotate the producer, consumer fields and perform the test\r\nexchanges.\r\n\r\n```\r\n@RunWith(JmsTestRunner.class)\r\n@Provider(\r\n        value = MockProvider.class,\r\n        configuration = MockConfiguration.class)\r\n```\r\n\r\nThe runner requires a JMS provider to run the tests. At this moment two\r\nproviders are available: MockProvider, which uses the MockRunner JMS\r\nprovider, and ActiveMqProvider, which creates and embedded ActiveMQ instance\r\nto run the tests (provided in another project). Others may be added in the\r\nfuture.\r\n\r\n\r\n\r\nMember variables must be annotated with appropriate methods.\r\n\r\n\r\n```\r\n@Producer\r\n```\r\n\r\nThis is the message producer. It is used to send a request to the server and\r\nusually represents a client sending a transaction. It shares the same\r\nsession as the consumer. If not specified, it will send requests to a default\r\nrequest queue (with replies set to the default response queue)\r\n\r\n```\r\n@Consumer\r\n```\r\n\r\nThis represents a message consumer on the client-side. It shares the same\r\nsession as the message producer.By default it is tied to the  default reply\r\nqueue.\r\n\r\n\r\nAddresses for both the @Consumer and @Producer can be specified with the\r\naddress property.\r\n\r\n\r\n```\r\n@Consumer(address = Defaults.REPLY_TO_QUEUE)\r\n```\r\n\r\n```\r\n@JmsSession\r\n```\r\n\r\nRepresents the active JMS Session.\r\n\r\n\r\n```\r\n@Listener\r\n```\r\n\r\nRepresents a server. It receives the transactions sent by a producer,\r\npseudo-process it and returns a message that is read by a consumer. At this\r\nmoment the default ServerListener is not thread-safe, therefore there can be\r\nonly one test method per class.\r\n\r\nDon't bother creating any of the fields. All of the fields properly annotated\r\n will be injected by the runner during startup.\r\n\r\n\r\nExamples\r\n----\r\n\r\n\r\nA basic synchronous send/receive test:\r\n\r\n```\r\n@RunWith(JmsTestRunner.class)\r\n@Provider(\r\n        value = ActiveMqProvider.class,\r\n        configuration = ActiveMqConfiguration.class)\r\npublic class SendReceiveTest extends AbstractSendReceive {\r\n\r\n    @Consumer\r\n    private MessageConsumer consumer;\r\n\r\n    @Producer\r\n    private MessageProducer producer;\r\n\r\n    @JmsSession\r\n    private Session session;\r\n\r\n    @Test\r\n    public void testSendReceive() throws JMSException {\r\n        TextMessage request = session.createTextMessage(\"test\");\r\n\r\n        producer.send(textMessage);\r\n\r\n        Message response = consumer.receive(5000);\r\n    }\r\n}\r\n```\r\n\r\nUsing a server listener:\r\n\r\n```\r\n@RunWith(JmsTestRunner.class)\r\n@Provider(\r\n        value = MockProvider.class,\r\n        configuration = MockConfiguration.class)\r\npublic class RequestReplyStringTest extends AbstractRequestReply<TextMessage> {\r\n    @Consumer(address = Defaults.REPLY_TO_QUEUE)\r\n    private MessageConsumer consumer;\r\n\r\n    @Producer\r\n    private MessageProducer producer;\r\n\r\n    @JmsSession\r\n    private Session session;\r\n\r\n    @Listener\r\n    private ServerListener listener;\r\n\r\n    @Test\r\n    public void testSendReceiveText() throws JMSException {\r\n        Destination replyTo = session.createQueue(Defaults.REPLY_TO_QUEUE);\r\n\r\n        Message request = session.createTextMessage(\"marco\");\r\n        request.setJMSReplyTo(replyTo);\r\n        request.setStringProperty(ServerListener.REPLY_BUILDER,\r\n                        StringReplyBuilder.class.getName());\r\n\r\n        producer.send(request);\r\n\r\n        Message response = consumer.receive(1000 * 5);\r\n        // handle the response\r\n    }\r\n}\r\n```\r\n\r\nTo customize the responses, so that you can elaborate more complex responses,\r\nmodify headers, etc, you can implement a ReplyBuilder. The interface it's\r\nsimple: given a Session and the request object, you can pseudo-process the\r\nrequest and give an adequate response that matches your tests.\r\n\r\n\r\n```\r\npublic class StringReplyBuilder implements ReplyBuilder {\r\n    public Message build(Session session, Message request) throws JMSException {\r\n        return Util.createMessage(session, \"polo\");\r\n    }\r\n}\r\n```\r\n\r\n\r\nDependencies\r\n----\r\n\r\nOnce compiled and installed, you can refer to the dependencies as:\r\n\r\n```\r\n<dependency>\r\n    <groupId>net.orpiske</groupId>\r\n    <artifactId>jms-test-util</artifactId>\r\n    <version>1.0.0-SNAPSHOT</version>\r\n</dependency>\r\n\r\n<dependency>\r\n    <groupId>net.orpiske</groupId>\r\n    <artifactId>jms-test-util</artifactId>\r\n    <version>1.0.0-SNAPSHOT</version>\r\n    <type>test-jar</type>\r\n    <scope>test</scope>\r\n</dependency>\r\n```\r\n\r\nRunning\r\n----\r\nThe tests are run with JUnit. A main class is provided for running via\r\ncommand-line but it is not yet documented.\r\n\r\n\r\nReferences\r\n----\r\n\r\n* [Main Site](http://orpiske.net/)\r\n* [ActiveMQ Provider](https://github.com/orpiske/jms-test-provider-activemq)\r\n\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}